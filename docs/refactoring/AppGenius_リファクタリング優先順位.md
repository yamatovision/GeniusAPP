# AppGenius リファクタリング優先順位と計画

本ドキュメントはコードベースの詳細分析に基づいて、リファクタリングの優先順位と具体的な計画を提示します。行数だけでなく、責務の分離、コードの重複、保守性の向上の観点から評価しています。

## リファクタリング優先順位

### 最優先（重大な設計上の問題あり）

1. **ScopeManagerPanel.ts** (3683行)
   - 問題: 単一ファイルで3600行を超える巨大なUIコンポーネント
   - 多数のUIハンドラ、データ処理ロジック、DOM操作が混在
   - WebViewメッセージハンドラが過剰に肥大化
   - 複数の責務（UI表示、データ処理、ファイル操作）が混在

2. **EnvironmentVariablesAssistantPanel.ts** (3421行)
   - 問題: 単一ファイルで3400行を超える巨大なUIコンポーネント
   - 多数の環境変数処理ロジックとUI操作が混在
   - 同様のパターンで大量のイベントハンドラーが散在

3. **AuthenticationService.ts** (1189行)
   - 問題: 認証に関するあらゆる処理が単一のクラスに集中
   - トークン管理、認証状態追跡、プロファイル操作など複数の責務
   - アプリ全体でシングルトンとして使用され依存関係が複雑

### 高優先度（パフォーマンスと保守性に影響）

4. **ClaudeCodeLauncherService.ts** (937行)
   - 問題: 複数の起動シナリオとターミナル管理ロジックが混在
   - 認証連携処理と起動ロジックが密結合
   - 複数のアシスタントから同様のパターンで呼び出されている

5. **ClaudeCodeAuthSync.ts** (988行)
   - 問題: 認証とトークン同期に関する処理が混在
   - 環境変数処理とファイルシステム操作が複雑に絡み合う
   - 他のモジュールと密結合

6. **DashboardPanel.ts** (2182行)
   - 問題: UIコンポーネントの肥大化
   - 多数のメッセージハンドラが混在
   - イベント処理ロジックと表示ロジックが分離されていない

### 中優先度（コード品質向上のため）

7. **aiService.ts** (1902行)
   - 問題: AI関連処理の集中
   - 複数のAI機能とAPI呼び出しが混在
   - エラー処理の重複

8. **AppGeniusStateManager.ts** (1389行)
   - 問題: 状態管理の中央集権化による肥大化
   - 多数の状態オブジェクトと購読者パターンの混在
   - 状態更新ロジックの複雑化

9. **extension.ts** (約580行)
   - 問題: 拡張機能初期化コードの肥大化
   - コマンド登録と機能初期化が混在
   - 複数のサービス初期化が単一ファイルに集中

## リファクタリング計画（詳細）

### 1. ScopeManagerPanel.ts のリファクタリング

**現状の問題:**
- 単一ファイルでUIコンポーネント、データ処理、ファイル操作が混在
- メッセージハンドラが過剰に肥大化（`_handleMessage` メソッドと各種 `_handle*` メソッド群）
- WebView関連のHTML生成と操作が複数の場所に散在
- 3600行を超えるコードサイズで可読性と保守性が著しく低下

**リファクタリング計画:**

1. **責務ごとのモジュール分割**
   - `ScopeManagerPanel.ts` - メインコントローラ、WebViewとの連携のみを担当（約600行）
   - `ScopeUIRenderer.ts` - HTML生成とUI表示ロジックを担当（約800行）
   - `ScopeDataManager.ts` - データモデルとMDファイル解析を担当（約700行）
   - `ScopeFileOperations.ts` - ファイル操作ロジックを担当（約400行）
   - `ScopeMessageHandlers.ts` - WebViewメッセージハンドラを担当（約700行）
   - `scope-manager.interfaces.ts` - 共通インターフェイスと型定義（約200行）

2. **UIコンポーネント最適化**
   - スコープリスト、スコープ詳細、ツールバーなどをコンポーネント単位で分割
   - WebViewとのメッセージ通信を整理し標準化
   - HTMLテンプレート生成を別モジュールに移動

3. **データフローの明確化**
   - 単方向データフローモデルを採用（状態更新 → UI更新）
   - イベントバスパターンによる依存関係の低減
   - モデル-ビュー-コントローラパターンの導入

4. **デッドコードと重複の排除**
   - 使用されていないヘルパー関数の削除
   - 類似のファイル操作関数の統合
   - 重複するUI生成ロジックの統合

### 2. ClaudeCodeLauncherService.ts のリファクタリング

**現状の問題:**
- 複数の起動シナリオ（スコープベース、モックアップ、プロンプト）が混在
- 認証処理とターミナル管理ロジックが密結合
- 環境変数設定と起動コマンド構築コードの重複
- 進捗管理と監視機能がメインロジックと混在

**リファクタリング計画:**

1. **責務ごとのモジュール分割**
   - `ClaudeCodeLauncherService.ts` - コアロジックと共通インターフェース（約300行）
   - `AuthSyncManager.ts` - 認証処理と同期機能（約250行）
   - `TerminalManager.ts` - ターミナル作成と管理（約150行）
   - `LaunchOptionBuilder.ts` - 起動オプションとコマンド構築（約100行）
   - `ProgressMonitor.ts` - 進捗管理と監視（約150行）

2. **起動シナリオの分離**
   - 各起動シナリオ（スコープ、モックアップ、プロンプト）を別クラスとして実装
   - 起動シナリオごとの専用インターフェースを定義
   - 共通のオプション構築ロジックを統合

3. **認証処理の最適化**
   - AuthSyncManagerによる認証状態の一元管理
   - トークンの同期と更新ロジックの分離
   - CLI認証状態検出の簡素化

4. **ターミナル管理の改善**
   - プラットフォーム固有の処理を明確に分離
   - 環境変数設定の統一
   - 共通コマンド構築テンプレートの導入

5. **プログレス監視機能の強化**
   - 非同期監視パターンの導入
   - ファイルウォッチャーと定期チェックの最適化
   - イベント通知の明確な構造化

### 3. AuthenticationService.ts のリファクタリング（部分的に対応済み）

**現状の問題:**
- 認証に関するあらゆる処理が単一クラスに集中している
- トークン管理、認証状態追跡、ユーザープロファイルなど複数の責務
- サービス間の依存関係が複雑でテスト困難
- エラー処理とリカバリーロジックが混在
- super_adminロールが適切に扱われていない問題があった（修正済み）

**対応済みの修正:**
- super_adminロールのマッピング修正（Role列挙型に追加）
- RoleFeatureMapとRoleDisplayNamesをsuper_adminに対応
- バックエンドとの連携を修正して適切なロール処理を実装

**リファクタリング計画:**

1. **責務ごとのモジュール分割**
   - `AuthenticationService.ts` - コアサービスとファサード（約300行）
   - `TokenService.ts` - トークン取得、保存、更新のみ担当（約250行）
   - `AuthStateManager.ts` - 認証状態の追跡と変更通知（約200行）
   - `UserProfileService.ts` - プロファイル操作専用（約150行）
   - `AuthRecoveryService.ts` - エラー復旧と再試行ロジック（約150行）
   - `auth.interfaces.ts` - 共通インターフェースと型定義（約100行）

2. **依存関係の逆転**
   - インターフェースベースの設計に移行
   - 依存性注入パターンの導入
   - テスタビリティの向上

3. **トークン管理の強化**
   - トークンの安全な保存と取得
   - リフレッシュトークンフローの整理
   - 有効期限管理の統一

4. **認証状態管理の改善**
   - 明確な状態遷移モデルの導入
   - イベントベースの通知システム
   - セッション管理の強化

## 期待される効果

1. **保守性の向上**
   - 責務の明確な分離による変更の局所化
   - シンプルなモジュールによるバグ発見の容易さ
   - コード理解のための学習曲線の緩和

2. **拡張性の向上**
   - インターフェースに基づく設計による差し替え可能性
   - 新機能追加時の既存コードへの影響最小化
   - プラグイン設計パターンの採用

3. **パフォーマンスの改善**
   - 必要なモジュールのみの読み込みによるメモリ効率化
   - 依存関係の明確化による初期化処理の最適化
   - 非同期処理の整理によるUI応答性の向上

4. **テスト容易性の向上**
   - 小さなモジュールの単体テスト
   - インターフェースを通じたモックの容易さ
   - 副作用の局所化によるテスト安定性

## 実装アプローチ

このリファクタリングは段階的に実施し、各段階で十分なテストを行うことで、機能的な問題の発生を最小限に抑えます。

1. **準備段階**
   - 詳細なコードレビューと依存関係分析
   - 各モジュールのインターフェース設計
   - 単体テストの設計と実装

2. **段階的な実装**
   - 1つのモジュールごとに分割と抽出
   - 既存コードを保ちながらの段階的移行
   - 各ステップでの機能テスト

3. **統合とクリーンアップ**
   - 新しいモジュール間の連携確認
   - デッドコードの削除
   - パフォーマンステストと最終調整

## 結論

この計画に従ってリファクタリングを実施することで、AppGeniusのコードベースは大幅に改善され、今後の拡張と保守が容易になります。特に優先度の高いコンポーネントから順次対応することで、効果的なリソース活用が可能です。