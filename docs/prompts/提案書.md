
  3. スコープ実装アシスタントドキュメントの更新

  スコープ実装アシスタント (scope_implementer.md)
  の以下の部分を更新します：

  4. **データモデル管理と型定義の厳格なルール**

     ### 単一の真実源の尊重
     - データモデルの定義は **必ず**
  `shared/index.ts` から取得する
     - APIエンドポイントパスは **必ず**
  `shared/api-paths.ts` から取得する
     - フロントエンドとバックエンドで同じモデル定
  義とAPIパスを使用する
     - 独自の型定義やハードコードされたAPIパスを作
  成せず、共通定義を使用する

     ### モデル・APIパス使用時の原則
     ```javascript
     // 正しい使用法
     import { UserType, AUTH } from
  '../../../shared';

     // UserTypeの型定義に基づいて実装
     const user: UserType = { ... };

     // APIパスの使用
     fetch(AUTH.LOGIN, { ... });

     // パスパラメータを含むエンドポイント
     fetch(LISTINGS.DETAIL(listingId), { ... });

     // 間違った使用法
     // const LOGIN_URL = '/api/v1/auth/login'; //
   ❌ パスをハードコードしない
     // fetch('/api/v1/auth/login', { ... });  //
  ❌ パスをハードコードしない

  ## 4. APIクライアントの実装例

  APIエンドポイントパスの一元管理を活用する具体的
  な実装例：

  ```typescript
  // /client/src/services/api.ts
  import axios from 'axios';
  import { API_BASE_PATH } from
  '../../shared/api-paths';

  // APIクライアントの基本設定
  const apiClient = axios.create({
    baseURL: process.env.REACT_APP_API_URL ||
  'http://localhost:4000',
    timeout: 10000,
    headers: {
      'Content-Type': 'application/json',
    },
  });

  // 認証トークンのインターセプター
  apiClient.interceptors.request.use(config => {
    const token =
  localStorage.getItem('authToken');
    if (token) {
      config.headers.Authorization = `Bearer
  ${token}`;
    }
    return config;
  });

  export default apiClient;

  // /client/src/services/auth.service.ts
  import apiClient from './api';
  import { AUTH } from '../../shared';
  import type { UserType, LoginRequest,
  RegisterRequest } from '../../shared';

  export const authService = {
    // ログイン
    login: async (credentials: LoginRequest) => {
      try {
        const response = await
  apiClient.post(AUTH.LOGIN, credentials);
        // トークンの保存処理など
        return response.data;
      } catch (error) {
        throw error;
      }
    },

    // ユーザー登録
    register: async (userData: RegisterRequest) =>
   {
      try {
        const response = await
  apiClient.post(AUTH.REGISTER, userData);
        return response.data;
      } catch (error) {
        throw error;
      }
    },

    // プロフィール取得
    getProfile: async () => {
      try {
        const response = await
  apiClient.get(AUTH.PROFILE);
        return response.data;
      } catch (error) {
        throw error;
      }
    },

    // トークンリフレッシュ
    refreshToken: async (refreshToken: string) =>
  {
      try {
        const response = await
  apiClient.post(AUTH.REFRESH_TOKEN, {
  refreshToken });
        return response.data;
      } catch (error) {
        throw error;
      }
    },
  };

  5. バックエンドでの一元管理APIパスの活用例

  // /server/src/api/routes/auth.routes.ts
  import express from 'express';
  import * as authController from
  '../controllers/auth.controller';
  import { AUTH } from
  '../../../shared/api-paths';

  // ベースパスを除去した相対パスを取得する関数
  const getRelativePath = (fullPath: string) => {
    return fullPath.replace('/api/v1', '');
  };

  const router = express.Router();

  // 各エンドポイントの設定
  router.post(getRelativePath(AUTH.LOGIN),
  authController.login);
  router.post(getRelativePath(AUTH.REGISTER),
  authController.register);
  router.post(getRelativePath(AUTH.REFRESH_TOKEN),
   authController.refreshToken);
  router.get(getRelativePath(AUTH.PROFILE),
  authMiddleware.authenticate,
  authController.getProfile);

  export default router;

  結論

  APIエンドポイントの一元管理を実現するために、既
  存の shared/index.ts を拡張し、新しい
  shared/api-paths.ts ファイルを導入することを提案
  します。これにより、フロントエンドとバックエンド
  で一貫したAPIパス定義が可能となり、修正時の漏れ
  やミスを大幅に削減できます。

  この変更をスコープマネージャーとスコープ実装アシ
  スタントのドキュメントに反映し、「単一の真実源」
  原則をデータモデルだけでなくAPIパスにも適用する
  ことで、よりメンテナンス性の高いコードベースを実
  現できます。