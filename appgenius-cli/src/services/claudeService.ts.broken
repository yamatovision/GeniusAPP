import axios from 'axios';
import { AIMessage, ClaudeResponse, StreamCallback, Tool, ToolUseResult } from '../types';
import { logger } from '../utils/logger';
import { configManager } from '../utils/configManager';
import { Readable } from 'stream';

// Claude API のベースURL
const CLAUDE_API_BASE_URL = 'https://api.anthropic.com/v1/messages';

// Claude モデル
export enum ClaudeModel {
  CLAUDE_3_OPUS = 'claude-3-opus-20240229',
  CLAUDE_3_SONNET = 'claude-3-sonnet-20240229',
  CLAUDE_3_HAIKU = 'claude-3-haiku-20240307',
  CLAUDE_3_SONNET_20250219 = 'claude-3-7-sonnet-20250219' // Claude 3.7
}

/**
 * Claude AI サービスのオプション
 */
export interface ClaudeServiceOptions {
  model?: ClaudeModel;
  maxTokens?: number;
  temperature?: number;
  systemPrompt?: string;
  streaming?: boolean;
}

/**
 * Claude AI サービスクラス
 * Claude APIを使用して自然言語処理を行う
 */
export class ClaudeService {
  private apiKey: string;
  private model: ClaudeModel;
  private maxTokens: number;
  private temperature: number;
  private systemPrompt: string;
  private tools: Map<string, Tool>;
  private conversation: AIMessage[] = [];
  private streaming: boolean = false; // ストリーミングモード
  
  // 並列ツール実行をサポートするための並列処理フラグ
  private parallelToolExecution: boolean = true;

  /**
   * コンストラクタ
   */
  constructor(options?: ClaudeServiceOptions) {
    const config = configManager.getConfig();
    this.apiKey = config.apiKey;
    this.model = options?.model || ClaudeModel.CLAUDE_3_SONNET_20250219; // デフォルトでClaude 3.7を使用
    this.maxTokens = options?.maxTokens || 100000; // ClaudeCodeと同じく大きなコンテキスト対応
    this.temperature = options?.temperature || 0.7;
    this.systemPrompt = options?.systemPrompt || this.getDefaultSystemPrompt();
    this.streaming = options?.streaming || false;
    this.tools = new Map();
    
    // ユーザー設定からストリーミングを読み込み
    if (config.userPreferences?.streamingEnabled !== undefined) {
      this.streaming = config.userPreferences.streamingEnabled;
    }
    
    // 並列ツール実行の設定
    this.parallelToolExecution = true;
    
    // システムプロンプトを会話履歴の最初に追加
    this.conversation = [
      { role: 'system', content: this.systemPrompt }
    ];
    
    logger.debug('Claude AIサービスを初期化しました', {
      model: this.model,
      maxTokens: this.maxTokens,
      temperature: this.temperature,
      streaming: this.streaming
    });
  }

  /**
   * デフォルトのシステムプロンプトを取得 - ClaudeCode互換
   */
  private getDefaultSystemPrompt(): string {
    return `You are Claude Code, Anthropic's official CLI for Claude.

You are an interactive CLI tool that helps users with software engineering tasks. You specialize in TypeScript, JavaScript, Node.js, and web development, but can assist with most programming languages.

IMPORTANT: Be concise, direct, and to the point. Keep your responses short and focused on exactly what the user asked. 
Minimize text before and after your actual answer. Only elaborate when explicitly asked.

When using tools:
- Be precise with file paths
- Search thoroughly but efficiently
- Verify changes carefully

For coding tasks:
1. Understand existing code conventions
2. Follow project patterns
3. Write clean, maintainable code
4. Verify solutions with tests when appropriate

When faced with complex problems:
- Break them down systematically
- Search code to understand the codebase
- Look for existing patterns to follow
- Implement solutions that match project style

CRITICAL: Answer concisely with minimal text. One-line answers are best when possible. Avoid explanations unless asked.
Respect the user's time by being direct and avoiding unnecessary elaboration.

IMPORTANT: Always run appropriate linting and typechecking commands after code changes if available.`;
  }

  /**
   * APIキーを設定
   */
  public setApiKey(apiKey: string): void {
    this.apiKey = apiKey;
    configManager.setApiKey(apiKey);
  }

  /**
   * ツールを登録
   */
  public registerTool(tool: Tool): void {
    this.tools.set(tool.name, tool);
    logger.debug(`ツールを登録しました: ${tool.name}`);
  }

  /**
   * 複数のツールを登録
   */
  public registerTools(tools: Tool[]): void {
    tools.forEach(tool => this.registerTool(tool));
  }

  /**
   * 会話履歴をクリア（システムプロンプトは保持）
   */
  public clearConversation(): void {
    this.conversation = [this.conversation[0]]; // システムプロンプトのみ保持
    logger.debug('会話履歴をクリアしました');
  }

  /**
   * 会話履歴を取得
   */
  public getConversation(): AIMessage[] {
    return [...this.conversation];
  }

  /**
   * システムプロンプトを更新
   */
  public updateSystemPrompt(systemPrompt: string): void {
    this.systemPrompt = systemPrompt;
    
    // 会話履歴の最初のメッセージを更新
    if (this.conversation.length > 0 && this.conversation[0].role === 'system') {
      this.conversation[0].content = systemPrompt;
    } else {
      this.conversation.unshift({ role: 'system', content: systemPrompt });
    }
    
    logger.debug('システムプロンプトを更新しました');
  }
  
  /**
   * ストリーミング設定を変更
   */
  public setStreaming(enabled: boolean): void {
    this.streaming = enabled;
    logger.debug(`ストリーミングモードを${enabled ? '有効' : '無効'}にしました`);
  }
  
  /**
   * 並列ツール実行の設定を変更
   */
  public setParallelToolExecution(enabled: boolean): void {
    this.parallelToolExecution = enabled;
    logger.debug(`並列ツール実行を${enabled ? '有効' : '無効'}にしました`);
  }

  /**
   * Claude APIにメッセージを送信
   * @param message ユーザーメッセージ
   * @param streamCallback ストリーミング用コールバック
   */
  public async sendMessage(message: string, streamCallback?: StreamCallback): Promise<string> {
    try {
      if (!this.apiKey) {
        const errorMessage = 'Claude APIキーが設定されていません';
        logger.error(errorMessage);
        throw new Error(errorMessage);
      }
      
      // ユーザーメッセージを会話履歴に追加
      this.conversation.push({ role: 'user', content: message });
      
      logger.debug('Claude APIにリクエスト送信', {
        model: this.model,
        messageCount: this.conversation.length
      });
      
      // システムメッセージを取得
      const systemMessage = this.conversation[0].content;
      
      // メッセージ配列からシステムメッセージを除外
      const messagesWithoutSystem = this.conversation.filter(msg => msg.role !== 'system');
      
      // リクエストボディを構築 - ツール定義を含める
      const requestBody = {
        model: this.model,
        messages: messagesWithoutSystem,
        max_tokens: this.maxTokens,
        temperature: this.temperature,
        system: systemMessage,
        tools: Array.from(this.tools.values()).map(tool => ({
          name: tool.name,
          description: tool.description,
          input_schema: {
            type: "object",
            properties: this.getToolParameters(tool.name),
            required: this.getRequiredParameters(tool.name)
          }
        })),
        stream: this.streaming || !!streamCallback // ストリーミングコールバックがある場合はストリーミングを有効化
      };
      
      // 共通のヘッダー
      const headers = {
        'x-api-key': this.apiKey,
        'anthropic-version': '2023-06-01',
        'content-type': 'application/json',
        'Accept': 'application/json',
        'anthropic-beta': 'tools-2024-06-10' // ツール機能のベータ版を有効化
      };
      
      // ストリーミングモードの場合
      if (requestBody.stream && streamCallback) {
        let fullResponse = '';
        
        try {
          // ストリーミングAPIリクエスト
          const response = await axios.post(CLAUDE_API_BASE_URL, requestBody, {
            headers,
            responseType: 'stream'
          });
          
          // レスポンスをストリームとして処理
          const stream = response.data as Readable;
          
          // チャンクを処理
          await new Promise<void>((resolve, reject) => {
            stream.on('data', (chunk) => {
              try {
                const lines = chunk.toString().split('\n').filter(Boolean);
                
                for (const line of lines) {
                  if (line.startsWith('data: ')) {
                    const data = line.slice(6);
                    
                    // ストリームの終了を示す[DONE]を検出
                    if (data === '[DONE]') {
                      resolve();
                      return;
                    }
                    
                    try {
                      const parsed = JSON.parse(data);
                      
                      if (parsed.type === 'content_block_delta' && parsed.delta && parsed.delta.text) {
                        // テキストデルタを取得
                        const textChunk = parsed.delta.text;
                        fullResponse += textChunk;
                        
                        // コールバックでクライアントに送信
                        streamCallback(textChunk);
                      }
                    } catch (e) {
                      logger.warn('ストリーミングデータのパースに失敗しました', e);
                    }
                  }
                }
              } catch (err) {
                logger.error('ストリームチャンクの処理中にエラーが発生しました', err);
              }
            });
            
            stream.on('end', () => {
              resolve();
            });
            
            stream.on('error', (err) => {
              logger.error('ストリーム処理中にエラーが発生しました', err);
              reject(err);
            });
          });
          
          // アシスタントの応答を会話履歴に追加
          this.conversation.push({ role: 'assistant', content: fullResponse });
          
          return fullResponse;
        } catch (error) {
          logger.error('ストリーミング中にエラーが発生しました', error);
          throw error;
        }
      } else {
        // 通常のAPIリクエスト
        const response = await axios.post<ClaudeResponse>(CLAUDE_API_BASE_URL, requestBody, {
          headers
        });
        
        // レスポンスを処理
        const claudeResponse = response.data;

      // テキスト部分の抽出
      const textContent = claudeResponse.content
        .filter(item => item.type === 'text')
        .map(item => item.text || '')
        .join('');
      
      // ツール使用部分も文字列に含める
      const toolUseContent = claudeResponse.content
        .filter(item => item.tool_use || item.tool_result)
        .map(item => {
          if (item.tool_use) {
            return `[ツール使用: ${item.tool_use.name}]`;
          } else if (item.tool_result) {
            return `[ツール結果: ${item.tool_result.content.substring(0, 30)}...]`;
          }
          return '';
        })
        .join('\n');
      
      // 最終的なアシスタントメッセージを構築
      const assistantMessage = [textContent, toolUseContent].filter(Boolean).join('\n');
      
      // アシスタントの応答を会話履歴に追加
      this.conversation.push({ role: 'assistant', content: assistantMessage });
      
      logger.debug('Claude APIからの応答を受信', {
        inputTokens: claudeResponse.usage.inputTokens,
        outputTokens: claudeResponse.usage.outputTokens
      });
      
      return assistantMessage;
    } catch (error) {
      if (axios.isAxiosError(error)) {
        logger.error('Claude API呼び出しエラー', error);
        throw new Error(`Claude API呼び出しエラー: ${error.message}`);
      } else {
        logger.error('Claude APIとの通信中に予期しないエラーが発生しました', error as Error);
        throw error;
      }
    }
  }

  /**
   * ツール使用リクエストを検出・実行（ネイティブツールサポート対応）
   */
  public async detectAndExecuteTools(message: string, streamCallback?: StreamCallback): Promise<{ 
    responseText: string; 
    toolResults: ToolUseResult[];
  }> {
    try {
      // 会話履歴にユーザーメッセージを追加
      this.conversation.push({ role: 'user', content: message });
      
      // ツール定義をAnthropicネイティブ形式で構築
      const toolDefinitions = Array.from(this.tools.values()).map(tool => ({
        name: tool.name,
        description: tool.description,
        input_schema: {
          type: "object",
          properties: this.getToolParameters(tool.name),
          required: this.getRequiredParameters(tool.name)
        }
      }));
      
      // 特別なシステムプロンプトを構築
      const toolPrompt = `You have access to the following tools:
${JSON.stringify(toolDefinitions, null, 2)}

To use a tool, respond with:
<function_calls>
<invoke name="ToolName">
<parameter name="paramName">paramValue</parameter>
</invoke>
</function_calls>`;
      
      // システムメッセージを取得（最初のメッセージが必ずシステムメッセージ）
      const baseSystemPrompt = this.conversation[0].content;
      
      // 元のシステムプロンプトにツールサポートを追加
      const combinedSystemPrompt = `${baseSystemPrompt}\n\n${toolPrompt}`;
      
      // ツール実行のためのカスタム会話履歴を作成
      const conversationHistory = [
        { role: 'system', content: combinedSystemPrompt },
        ...this.conversation.slice(1) // システムメッセージ以外をコピー
      ];
      
      // ツール実行用のメッセージリストをAPIフォーマットに変換
      const messagesWithoutSystem = conversationHistory.filter(msg => msg.role !== 'system');
      
      // APIリクエスト設定
      const requestBody = {
        model: this.model,
        messages: messagesWithoutSystem,
        max_tokens: this.maxTokens,
        temperature: this.temperature,
        system: combinedSystemPrompt,
        tools: Array.from(this.tools.values()).map(tool => ({
          name: tool.name,
          description: tool.description,
          input_schema: {
            type: "object",
            properties: this.getToolParameters(tool.name),
            required: this.getRequiredParameters(tool.name)
          }
        })),
        stream: this.streaming || !!streamCallback // ストリーミングコールバックがある場合はストリーミングを有効化
      };
      
      // 共通のヘッダー
      const headers = {
        'x-api-key': this.apiKey,
        'anthropic-version': '2023-06-01',
        'content-type': 'application/json',
        'Accept': 'application/json',
        'anthropic-beta': 'tools-2024-06-10' // ツール機能のベータ版を有効化
      };
      
      // ツール使用結果を格納する配列
      const toolResults: ToolUseResult[] = [];
      
      // ストリーミングモードの場合
      if (requestBody.stream && streamCallback) {
        let fullResponse = '';
        
        try {
          // ストリーミングAPIリクエスト
          const response = await axios.post(CLAUDE_API_BASE_URL, requestBody, {
            headers,
            responseType: 'stream'
          });
          
          // レスポンスをストリームとして処理
          const stream = response.data as Readable;
          
          // チャンクを処理
          await new Promise<void>((resolve, reject) => {
            stream.on('data', (chunk) => {
              try {
                const lines = chunk.toString().split('\n').filter(Boolean);
                
                for (const line of lines) {
                  if (line.startsWith('data: ')) {
                    const data = line.slice(6);
                    
                    // ストリームの終了を示す[DONE]を検出
                    if (data === '[DONE]') {
                      resolve();
                      return;
                    }
                    
                    try {
                      const parsed = JSON.parse(data);
                      
                      if (parsed.type === 'content_block_delta' && parsed.delta && parsed.delta.text) {
                        // テキストデルタを取得
                        const textChunk = parsed.delta.text;
                        fullResponse += textChunk;
                        
                        // コールバックでクライアントに送信
                        streamCallback(textChunk);
                      }
                    } catch (e) {
                      logger.warn('ストリーミングデータのパースに失敗しました', e);
                    }
                  }
                }
              } catch (err) {
                logger.error('ストリームチャンクの処理中にエラーが発生しました', err);
              }
            });
            
            stream.on('end', () => {
              resolve();
            });
            
            stream.on('error', (err) => {
              logger.error('ストリーム処理中にエラーが発生しました', err);
              reject(err);
            });
          });
          
          // アシスタントの応答を会話履歴に追加
          this.conversation.push({ role: 'assistant', content: fullResponse });
          
          return {
            responseText: fullResponse,
            toolResults
          };
        } catch (error) {
          logger.error('ストリーミング中にエラーが発生しました', error);
          throw error;
        }
      } else {
        // ストリーミングなしのAPIリクエスト
        const response = await axios.post<ClaudeResponse>(CLAUDE_API_BASE_URL, requestBody, {
          headers
        });
        
        // レスポンスを処理
        const claudeResponse = response.data;
        
        // テキスト部分の抽出
        const textContent = claudeResponse.content
          .filter(item => item.type === 'text')
          .map(item => item.text || '')
          .join('');
        
        // ツール使用部分を収集
        const toolUseTasks: Array<{
          toolName: string;
          toolArgs: any;
          toolUseId: string;
        }> = [];

        for (const contentBlock of claudeResponse.content) {
          if (contentBlock.tool_use) {
            toolUseTasks.push({
              toolName: contentBlock.tool_use.name,
              toolArgs: contentBlock.tool_use.input,
              toolUseId: contentBlock.tool_use.id
            });
          }
        }
        
        // 並列処理を最適化 - 並列実行可能なものは一括処理
        if (this.parallelToolExecution && toolUseTasks.length > 0) {
          logger.debug(`${toolUseTasks.length}個のツールを並列実行します`);
          
          // 並列でツールを実行
          const results = await Promise.all(toolUseTasks.map(async ({ toolName, toolArgs, toolUseId }) => {
            const tool = this.tools.get(toolName);
            
            if (!tool) {
              logger.warn(`ツールが見つかりません: ${toolName}`);
              return {
                toolName,
                args: toolArgs,
                result: null,
                error: `ツール "${toolName}" が見つかりません`,
                errorType: 'notFound'
              };
            }
            
            try {
              logger.debug(`ツール実行: ${toolName}`);
              const startTime = Date.now();
              const result = await tool.execute(toolArgs);
              const duration = Date.now() - startTime;
              
              logger.debug(`ツール実行完了: ${toolName} (${duration}ms)`);
              
              return {
                toolName,
                args: toolArgs,
                result,
                duration
              };
            } catch (toolError: any) {
              logger.error(`ツール実行エラー (${toolName}): ${toolError.message}`, toolError);
              
              // エラー情報を記録（拡張エラー情報があれば取得）
              return {
                toolName,
                args: toolArgs,
                result: null,
                error: toolError.message,
                errorType: toolError.errorType || 'execution',
                suggestions: toolError.suggestions,
                retryOptions: toolError.retryOptions
              };
            }
          }));
          
          // 結果を統合
          toolResults.push(...results);
        } else {
          // 従来の逐次実行
          for (const { toolName, toolArgs, toolUseId } of toolUseTasks) {
            logger.debug(`ツール使用を検出: ${toolName}`);
            
            const tool = this.tools.get(toolName);
            
            if (tool) {
              try {
                logger.debug(`ツール実行: ${toolName}`);
                const startTime = Date.now();
                const result = await tool.execute(toolArgs);
                const duration = Date.now() - startTime;
                
                // ツール実行結果を記録
                toolResults.push({
                  toolName,
                  args: toolArgs,
                  result,
                  duration
                });
                
                logger.debug(`ツール実行結果: ${JSON.stringify(result).substring(0, 100)}...`);
              } catch (toolError: any) {
                logger.error(`ツール実行エラー (${toolName}): ${toolError.message}`, toolError);
                
                // エラー情報を記録
                const errorResult: ToolUseResult = {
                  toolName,
                  args: toolArgs,
                  result: null,
                  error: toolError.message,
                  errorType: toolError.errorType || 'execution',
                  suggestions: toolError.suggestions,
                  retryOptions: toolError.retryOptions
                };
                
                // エラー種別や提案があれば追加
                if (toolError.errorType) {
                  errorResult.errorType = toolError.errorType;
                }
                
                if (toolError.suggestions) {
                  errorResult.suggestions = toolError.suggestions;
                }
                
                if (toolError.retryOptions) {
                  errorResult.retryOptions = toolError.retryOptions;
                }
                
                toolResults.push(errorResult);
              }
            } else {
              logger.error(`未知のツールを呼び出そうとしました: ${toolName}`);
              
              // 未知のツールエラーを記録
              toolResults.push({
                toolName,
                args: toolArgs,
                result: null,
                error: `ツール "${toolName}" は利用できません`,
                errorType: 'unknown'
              });
            }
          }
        }
        
        // アシスタント応答を会話履歴に追加
        this.conversation.push({ role: 'assistant', content: textContent });
        
        // 結果を返す
        return {
          responseText: textContent,
          toolResults
        };
      }
    } catch (error) {
      logger.error('ツール検出・実行中にエラーが発生しました', error);
      
      if (axios.isAxiosError(error)) {
        throw new Error(`Claude API呼び出しエラー: ${error.message}`);
      }
      
      throw error;
    }
  }
  
  /**
   * ツールパラメータを取得
   */
  private getToolParameters(toolName: string): any {
    // ツール名に基づいてパラメータ定義を返す
    // 本来はリフレクションやスキーマ定義から取得すべきだが、簡易実装として
    // 主要ツールのパラメータを手動で定義
    switch (toolName) {
      case 'View':
        return {
          file_path: { type: 'string', description: 'Path to the file to read' },
          offset: { type: 'number', description: 'Line offset to start reading from' },
          limit: { type: 'number', description: 'Maximum number of lines to read' }
        };
      case 'Edit':
        return {
          file_path: { type: 'string', description: 'Path to the file to edit' },
          old_string: { type: 'string', description: 'Text to replace' },
          new_string: { type: 'string', description: 'Replacement text' }
        };
      case 'Replace':
        return {
          file_path: { type: 'string', description: 'Path to the file to write' },
          content: { type: 'string', description: 'Content to write to the file' }
        };
      case 'GlobTool':
        return {
          pattern: { type: 'string', description: 'Glob pattern to match files' },
          path: { type: 'string', description: 'Directory to search in' }
        };
      case 'GrepTool':
        return {
          pattern: { type: 'string', description: 'Pattern to search for in files' },
          path: { type: 'string', description: 'Directory to search in' },
          include: { type: 'string', description: 'File pattern to include' }
        };
      case 'LS':
        return {
          path: { type: 'string', description: 'Directory to list' },
          ignore: { type: 'array', items: { type: 'string' }, description: 'Patterns to ignore' }
        };
      case 'Bash':
        return {
          command: { type: 'string', description: 'Command to execute' },
          timeout: { type: 'number', description: 'Timeout in milliseconds' }
        };
      case 'BatchEdit':
        return {
          files: { 
            type: 'array', 
            items: {
              type: 'object',
              properties: {
                file_path: { type: 'string' },
                operations: { 
                  type: 'array', 
                  items: {
                    type: 'object',
                    properties: {
                      old_string: { type: 'string' },
                      new_string: { type: 'string' }
                    }
                  }
                }
              }
            }
          }
        };
      case 'BatchReplace':
        return {
          files: { 
            type: 'array', 
            items: {
              type: 'object',
              properties: {
                file_path: { type: 'string' },
                content: { type: 'string' }
              }
            }
          }
        };
      case 'Refactor':
        return {
          pattern: { type: 'string' },
          replacement: { type: 'string' },
          include: { type: 'string' },
          path: { type: 'string' },
          regex: { type: 'boolean' },
          dryRun: { type: 'boolean' },
          caseSensitive: { type: 'boolean' },
          wholeWord: { type: 'boolean' },
          maxFiles: { type: 'number' }
        };
      default:
        return {}; // 未知のツールの場合は空オブジェクトを返す
    }
  }
  
  /**
   * 必須パラメータを取得
   */
  private getRequiredParameters(toolName: string): string[] {
    // ツール名に基づいて必須パラメータを返す
    switch (toolName) {
      case 'View':
        return ['file_path'];
      case 'Edit':
        return ['file_path', 'old_string', 'new_string'];
      case 'Replace':
        return ['file_path', 'content'];
      case 'GlobTool':
        return ['pattern'];
      case 'GrepTool':
        return ['pattern'];
      case 'LS':
        return ['path'];
      case 'Bash':
        return ['command'];
      case 'BatchEdit':
        return ['files'];
      case 'BatchReplace':
        return ['files'];
      case 'Refactor':
        return ['pattern', 'replacement', 'include'];
      default:
        return [];
    }
  }
}