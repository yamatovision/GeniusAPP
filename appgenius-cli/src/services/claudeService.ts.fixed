import axios from 'axios';
import { AIMessage, ClaudeResponse, StreamCallback, Tool, ToolUseResult } from '../types';
import { logger } from '../utils/logger';
import { configManager } from '../utils/configManager';
import { Readable } from 'stream';

// Claude API のベースURL
const CLAUDE_API_BASE_URL = 'https://api.anthropic.com/v1/messages';

// Claude モデル
export enum ClaudeModel {
  CLAUDE_3_OPUS = 'claude-3-opus-20240229',
  CLAUDE_3_SONNET = 'claude-3-sonnet-20240229',
  CLAUDE_3_HAIKU = 'claude-3-haiku-20240307',
  CLAUDE_3_SONNET_20250219 = 'claude-3-7-sonnet-20250219' // Claude 3.7
}

/**
 * Claude AI サービスのオプション
 */
export interface ClaudeServiceOptions {
  model?: ClaudeModel;
  maxTokens?: number;
  temperature?: number;
  systemPrompt?: string;
  streaming?: boolean;
}

/**
 * Claude AI サービスクラス
 * Claude APIを使用して自然言語処理を行う
 */
export class ClaudeService {
  private apiKey: string;
  private model: ClaudeModel;
  private maxTokens: number;
  private temperature: number;
  private systemPrompt: string;
  private tools: Map<string, Tool>;
  private conversation: AIMessage[] = [];
  private streaming: boolean = false; // ストリーミングモード
  
  // 並列ツール実行をサポートするための並列処理フラグ
  private parallelToolExecution: boolean = true;

  /**
   * コンストラクタ
   */
  constructor(options?: ClaudeServiceOptions) {
    const config = configManager.getConfig();
    this.apiKey = config.apiKey;
    this.model = options?.model || ClaudeModel.CLAUDE_3_SONNET_20250219; // デフォルトでClaude 3.7を使用
    this.maxTokens = options?.maxTokens || 4096; // 適切なサイズに調整（上限は32k）
    this.temperature = options?.temperature || 0.7;
    this.systemPrompt = options?.systemPrompt || this.getDefaultSystemPrompt();
    this.streaming = options?.streaming || false;
    this.tools = new Map();
    
    // ユーザー設定からストリーミングを読み込み
    if (config.userPreferences?.streamingEnabled !== undefined) {
      this.streaming = config.userPreferences.streamingEnabled;
    }
    
    // 並列ツール実行の設定
    this.parallelToolExecution = true;
    
    // システムプロンプトを会話履歴の最初に追加
    this.conversation = [
      { role: 'system', content: this.systemPrompt }
    ];
    
    logger.debug('Claude AIサービスを初期化しました', {
      model: this.model,
      maxTokens: this.maxTokens,
      temperature: this.temperature,
      streaming: this.streaming
    });
  }

  /**
   * デフォルトのシステムプロンプトを取得
   */
  private getDefaultSystemPrompt(): string {
    return `あなたはAppGeniusです。ソフトウェア開発に特化したAIアシスタントです。
コーディング、ソフトウェアアーキテクチャ、デバッグ、機能実装などのタスクでユーザーを支援します。
ユーザーがタスクを依頼したら：

1. 問題を分解する
2. 明確な説明を提供する
3. 整った構造の慣用的なコードを生成する
4. テストとベストプラクティスのガイダンスを提供する

ファイル操作のためのツールにアクセスでき、ファイルの検索、読み取り、編集ができます。
これらのツールを使用する際は、特にファイルパスに対して正確かつ慎重に扱ってください。

あなたは「拡張思考」が可能です - 複雑な問題に直面したとき、それをステップに分解し、
システマティックに取り組み、その推論を示します。これは以下のようなタスクに役立ちます：
- 複雑なコードベースの理解
- ソフトウェアアーキテクチャの設計
- 難しい問題のデバッグ
- パフォーマンス問題の最適化

TypeScript、JavaScript、Node.js、ウェブ開発に特に精通していますが、ほとんどのプログラミング言語をサポートできます。
常にクリーンで保守性が高く、効率的なコードの作成を優先してください。

重要: 支援において積極的かつ徹底的であること。ユーザーが明示的に尋ねたこと以上の潜在的な問題や改善点に気づいた場合は、丁寧に言及してください。

すべての回答は必ず日本語で行ってください。英語での回答は避けてください。`;
  }

  /**
   * APIキーを設定
   */
  public setApiKey(apiKey: string): void {
    this.apiKey = apiKey;
    configManager.setApiKey(apiKey);
  }

  /**
   * ツールを登録
   */
  public registerTool(tool: Tool): void {
    this.tools.set(tool.name, tool);
    logger.debug(`ツールを登録しました: ${tool.name}`);
  }

  /**
   * 複数のツールを登録
   */
  public registerTools(tools: Tool[]): void {
    tools.forEach(tool => this.registerTool(tool));
  }

  /**
   * 会話履歴をクリア（システムプロンプトは保持）
   */
  public clearConversation(): void {
    this.conversation = [this.conversation[0]]; // システムプロンプトのみ保持
    logger.debug('会話履歴をクリアしました');
  }

  /**
   * 会話履歴を取得
   */
  public getConversation(): AIMessage[] {
    return [...this.conversation];
  }

  /**
   * システムプロンプトを更新
   */
  public updateSystemPrompt(systemPrompt: string): void {
    this.systemPrompt = systemPrompt;
    
    // 会話履歴の最初のメッセージを更新
    if (this.conversation.length > 0 && this.conversation[0].role === 'system') {
      this.conversation[0].content = systemPrompt;
    } else {
      this.conversation.unshift({ role: 'system', content: systemPrompt });
    }
    
    logger.debug('システムプロンプトを更新しました');
  }
  
  /**
   * ストリーミング設定を変更
   */
  public setStreaming(enabled: boolean): void {
    this.streaming = enabled;
    logger.debug(`ストリーミングモードを${enabled ? '有効' : '無効'}にしました`);
  }
  
  /**
   * 並列ツール実行の設定を変更
   */
  public setParallelToolExecution(enabled: boolean): void {
    this.parallelToolExecution = enabled;
    logger.debug(`並列ツール実行を${enabled ? '有効' : '無効'}にしました`);
  }

  /**
   * Claude APIにメッセージを送信
   * @param message ユーザーメッセージ
   * @param streamCallback ストリーミング用コールバック
   */
  public async sendMessage(message: string, streamCallback?: StreamCallback): Promise<string> {
    try {
      if (!this.apiKey) {
        const errorMessage = 'Claude APIキーが設定されていません';
        logger.error(errorMessage);
        throw new Error(errorMessage);
      }
      
      // ユーザーメッセージを会話履歴に追加
      this.conversation.push({ role: 'user', content: message });
      
      logger.debug('Claude APIにリクエスト送信', {
        model: this.model,
        messageCount: this.conversation.length
      });
      
      // システムメッセージを取得
      const systemMessage = this.conversation[0].content;
      
      // メッセージ配列からシステムメッセージを除外
      const messagesWithoutSystem = this.conversation.filter(msg => msg.role !== 'system');
      
      // リクエストボディを構築 - ツール定義を含める
      const requestBody = {
        model: this.model,
        messages: messagesWithoutSystem,
        max_tokens: this.maxTokens,
        temperature: this.temperature,
        system: systemMessage,
        tools: Array.from(this.tools.values()).map(tool => ({
          name: tool.name,
          description: tool.description,
          input_schema: {
            type: "object",
            properties: this.getToolParameters(tool.name),
            required: this.getRequiredParameters(tool.name)
          }
        })),
        stream: this.streaming || !!streamCallback // ストリーミングコールバックがある場合はストリーミングを有効化
      };
      
      // 共通のヘッダー - 更新されたバージョン
      const headers = {
        'x-api-key': this.apiKey,
        'anthropic-version': '2023-06-01',
        'content-type': 'application/json',
        'Accept': 'application/json'
        // ベータタグは不要 - エラーの原因になる可能性があるため削除
      };
      
      // ストリーミングモードの場合
      if (requestBody.stream && streamCallback) {
        let fullResponse = '';
        
        try {
          // ストリーミングAPIリクエスト
          const response = await axios.post(CLAUDE_API_BASE_URL, requestBody, {
            headers,
            responseType: 'stream'
          });
          
          // レスポンスをストリームとして処理
          const stream = response.data as Readable;
          
          // チャンクを処理
          await new Promise<void>((resolve, reject) => {
            stream.on('data', (chunk) => {
              try {
                const lines = chunk.toString().split('\n').filter(Boolean);
                
                for (const line of lines) {
                  if (line.startsWith('data: ')) {
                    const data = line.slice(6);
                    
                    // ストリームの終了を示す[DONE]を検出
                    if (data === '[DONE]') {
                      resolve();
                      return;
                    }
                    
                    try {
                      const parsed = JSON.parse(data);
                      
                      if (parsed.type === 'content_block_delta' && parsed.delta && parsed.delta.text) {
                        // テキストデルタを取得
                        const textChunk = parsed.delta.text;
                        fullResponse += textChunk;
                        
                        // コールバックでクライアントに送信
                        streamCallback(textChunk);
                      }
                    } catch (e) {
                      logger.warn('ストリーミングデータのパースに失敗しました', e);
                    }
                  }
                }
              } catch (err) {
                logger.error('ストリームチャンクの処理中にエラーが発生しました', err as Error);
              }
            });
            
            stream.on('end', () => {
              resolve();
            });
            
            stream.on('error', (err) => {
              logger.error('ストリーム処理中にエラーが発生しました', err as Error);
              reject(err);
            });
          });
          
          // アシスタントの応答を会話履歴に追加
          this.conversation.push({ role: 'assistant', content: fullResponse });
          
          return fullResponse;
        } catch (error) {
          logger.error('ストリーミング中にエラーが発生しました', error as Error);
          throw error;
        }
      } else {
        // 通常のAPIリクエスト
        const response = await axios.post<ClaudeResponse>(CLAUDE_API_BASE_URL, requestBody, {
          headers
        });
        
        // レスポンスを処理
        const claudeResponse = response.data;

        // テキスト部分の抽出
        const textContent = claudeResponse.content
          .filter(item => item.type === 'text')
          .map(item => item.text || '')
          .join('');
        
        // ツール使用部分も文字列に含める
        const toolUseContent = claudeResponse.content
          .filter(item => item.tool_use || item.tool_result)
          .map(item => {
            if (item.tool_use) {
              return `[ツール使用: ${item.tool_use.name}]`;
            } else if (item.tool_result) {
              return `[ツール結果: ${item.tool_result.content.substring(0, 30)}...]`;
            }
            return '';
          })
          .join('\n');
        
        // 最終的なアシスタントメッセージを構築
        const assistantMessage = [textContent, toolUseContent].filter(Boolean).join('\n');
        
        // アシスタントの応答を会話履歴に追加
        this.conversation.push({ role: 'assistant', content: assistantMessage });
        
        logger.debug('Claude APIからの応答を受信', {
          inputTokens: claudeResponse.usage.inputTokens,
          outputTokens: claudeResponse.usage.outputTokens
        });
        
        return assistantMessage;
      }
    } catch (error) {
      if (axios.isAxiosError(error)) {
        logger.error('Claude API呼び出しエラー', error);
        throw new Error(`Claude API呼び出しエラー: ${error.message}`);
      } else {
        logger.error('Claude APIとの通信中に予期しないエラーが発生しました', error as Error);
        throw error;
      }
    }
  }

  /**
   * ツール使用リクエストを検出・実行（ネイティブツールサポート対応）
   */
  public async detectAndExecuteTools(message: string, streamCallback?: StreamCallback): Promise<{ 
    responseText: string; 
    toolResults: ToolUseResult[];
  }> {
    try {
      // 会話履歴にユーザーメッセージを追加
      this.conversation.push({ role: 'user', content: message });
      
      // ツール定義をAnthropicネイティブ形式で構築
      const toolDefinitions = Array.from(this.tools.values()).map(tool => ({
        name: tool.name,
        description: tool.description,
        input_schema: {
          type: "object",
          properties: this.getToolParameters(tool.name),
          required: this.getRequiredParameters(tool.name)
        }
      }));
      
      // 特別なシステムプロンプトを構築
      const toolPrompt = `あなたは以下のツールを使用できます:
${JSON.stringify(toolDefinitions, null, 2)}

ツールを使用するには、以下の形式で応答してください:
<function_calls>
<invoke name="ToolName">
<parameter name="paramName">paramValue</parameter>
</invoke>
</function_calls>

必ず日本語でユーザーとコミュニケーションを取ってください。
ツールの実行結果は常に日本語で説明してください。
英語での回答は避け、すべての出力を日本語に統一してください。`;
      
      // システムメッセージを取得（最初のメッセージが必ずシステムメッセージ）
      const baseSystemPrompt = this.conversation[0].content;
      
      // 元のシステムプロンプトにツールサポートを追加
      const combinedSystemPrompt = `${baseSystemPrompt}\n\n${toolPrompt}`;
      
      // ツール実行のためのカスタム会話履歴を作成
      const conversationHistory = [
        { role: 'system', content: combinedSystemPrompt },
        ...this.conversation.slice(1) // システムメッセージ以外をコピー
      ];
      
      // 会話履歴を更新 - システムプロンプトをツールサポート付きのものに置き換え
      this.conversation[0].content = combinedSystemPrompt;
      
      // ツール実行結果を格納する配列
      const toolResults: ToolUseResult[] = [];
      
      // ユーザーからのメッセージを送信してアシスタントの応答を取得
      const response = await this.sendMessage(message, streamCallback);
      
      // 応答からツール呼び出しを検出して実行
      const functionCallPattern = /<function_calls>([\s\S]*?)<\/function_calls>/g;
      const invokePattern = /<invoke name="([\w]+)">([\s\S]*?)<\/invoke>/g;
      const paramPattern = /<parameter name="([\w]+)">([\s\S]*?)<\/parameter>/g;
      
      let responseText = response;
      let functionCallsDetected = false;
      
      // 関数呼び出しブロックを検出
      const functionCallMatches = [...response.matchAll(functionCallPattern)];
      
      for (const functionCallMatch of functionCallMatches) {
        const functionCallBlock = functionCallMatch[1];
        functionCallsDetected = true;
        
        // ツール呼び出しを検出
        const invokeMatches = [...functionCallBlock.matchAll(invokePattern)];
        
        for (const invokeMatch of invokeMatches) {
          const toolName = invokeMatch[1];
          const paramsBlock = invokeMatch[2];
          
          // 対応するツールがあるか確認
          const tool = this.tools.get(toolName);
          
          if (tool) {
            // パラメータを解析
            const params: Record<string, any> = {};
            const paramMatches = [...paramsBlock.matchAll(paramPattern)];
            
            for (const paramMatch of paramMatches) {
              const paramName = paramMatch[1];
              const paramValue = paramMatch[2].trim();
              
              // パラメータの値を適切な型に変換（数値、配列など）
              try {
                // 数値、真偽値、配列、オブジェクトの場合はJSONとしてパース
                if (/^(\d+|\d+\.\d+|true|false|\[.*\]|\{.*\})$/.test(paramValue)) {
                  params[paramName] = JSON.parse(paramValue);
                } else {
                  // それ以外は文字列として扱う
                  params[paramName] = paramValue;
                }
              } catch {
                // JSONパースに失敗した場合は文字列として扱う
                params[paramName] = paramValue;
              }
            }
            
            try {
              // ツールを実行
              logger.debug(`ツール ${toolName} を実行中...`, params);
              const result = await tool.execute(params);
              
              // 結果を保存
              toolResults.push({
                toolName,
                result,
                success: true
              });
              
              // レスポンステキストからツール呼び出しを結果に置き換え
              responseText = responseText.replace(
                functionCallMatch[0], 
                `**ツール実行結果 (${toolName}):**\n\n${JSON.stringify(result, null, 2)}`
              );
            } catch (error) {
              // ツール実行エラー
              const errorMessage = error instanceof Error ? error.message : String(error);
              
              logger.error(`ツール ${toolName} の実行中にエラーが発生しました: ${errorMessage}`);
              
              toolResults.push({
                toolName,
                error: errorMessage,
                success: false
              });
              
              // レスポンステキストからツール呼び出しをエラーメッセージに置き換え
              responseText = responseText.replace(
                functionCallMatch[0], 
                `**ツール実行エラー (${toolName}):**\n\n${errorMessage}`
              );
            }
          } else {
            // 不明なツール
            logger.warn(`不明なツールが要求されました: ${toolName}`);
            
            toolResults.push({
              toolName,
              error: `不明なツール: ${toolName}`,
              success: false
            });
            
            // レスポンステキストからツール呼び出しをエラーメッセージに置き換え
            responseText = responseText.replace(
                functionCallMatch[0], 
                `**ツールエラー:**\n\n不明なツール: ${toolName}`
              );
          }
        }
      }
      
      if (functionCallsDetected) {
        logger.info(`${toolResults.length}個のツールが実行されました`);
      }
      
      return {
        responseText,
        toolResults
      };
    } catch (error) {
      logger.error('ツール検出・実行中にエラーが発生しました', error as Error);
      
      if (axios.isAxiosError(error)) {
        throw new Error(`Claude API呼び出しエラー: ${error.message}`);
      }
      
      throw error;
    }
  }
  
  /**
   * ツールパラメータを取得
   */
  private getToolParameters(toolName: string): Record<string, any> {
    // ツール名に基づいてパラメータ定義を返す
    // 本来はリフレクションやスキーマ定義から取得すべきだが、簡易実装として
    // 主要ツールのパラメータを手動で定義
    switch (toolName) {
      case 'View':
        return {
          file_path: { type: 'string', description: 'Path to the file to read' },
          offset: { type: 'number', description: 'Line offset to start reading from' },
          limit: { type: 'number', description: 'Maximum number of lines to read' }
        };
      case 'Edit':
        return {
          file_path: { type: 'string', description: 'Path to the file to edit' },
          old_string: { type: 'string', description: 'Text to replace' },
          new_string: { type: 'string', description: 'Replacement text' }
        };
      case 'Replace':
        return {
          file_path: { type: 'string', description: 'Path to the file to write' },
          content: { type: 'string', description: 'Content to write to the file' }
        };
      case 'GlobTool':
        return {
          pattern: { type: 'string', description: 'Glob pattern to match files' },
          path: { type: 'string', description: 'Directory to search in' }
        };
      case 'GrepTool':
        return {
          pattern: { type: 'string', description: 'Pattern to search for in files' },
          path: { type: 'string', description: 'Directory to search in' },
          include: { type: 'string', description: 'File pattern to include' }
        };
      case 'LS':
        return {
          path: { type: 'string', description: 'Directory to list' },
          ignore: { type: 'array', items: { type: 'string' }, description: 'Patterns to ignore' }
        };
      case 'Bash':
        return {
          command: { type: 'string', description: 'Command to execute' },
          timeout: { type: 'number', description: 'Timeout in milliseconds' }
        };
      case 'BatchEdit':
        return {
          files: { 
            type: 'array', 
            items: {
              type: 'object',
              properties: {
                file_path: { type: 'string' },
                operations: { 
                  type: 'array', 
                  items: {
                    type: 'object',
                    properties: {
                      old_string: { type: 'string' },
                      new_string: { type: 'string' }
                    }
                  }
                }
              }
            }
          }
        };
      case 'BatchReplace':
        return {
          files: { 
            type: 'array', 
            items: {
              type: 'object',
              properties: {
                file_path: { type: 'string' },
                content: { type: 'string' }
              }
            }
          }
        };
      case 'Refactor':
        return {
          pattern: { type: 'string' },
          replacement: { type: 'string' },
          include: { type: 'string' },
          path: { type: 'string' },
          regex: { type: 'boolean' },
          dryRun: { type: 'boolean' },
          caseSensitive: { type: 'boolean' },
          wholeWord: { type: 'boolean' },
          maxFiles: { type: 'number' }
        };
      case 'dispatch_agent':
        return {
          prompt: { type: 'string', description: 'The task for the agent to perform' }
        };
      default:
        return {}; // 未知のツールの場合は空オブジェクトを返す
    }
  }
  
  /**
   * 必須パラメータを取得
   */
  private getRequiredParameters(toolName: string): string[] {
    // ツール名に基づいて必須パラメータを返す
    switch (toolName) {
      case 'View':
        return ['file_path'];
      case 'Edit':
        return ['file_path', 'old_string', 'new_string'];
      case 'Replace':
        return ['file_path', 'content'];
      case 'GlobTool':
        return ['pattern'];
      case 'GrepTool':
        return ['pattern'];
      case 'LS':
        return ['path'];
      case 'Bash':
        return ['command'];
      case 'BatchEdit':
        return ['files'];
      case 'BatchReplace':
        return ['files'];
      case 'Refactor':
        return ['pattern', 'replacement', 'include'];
      case 'dispatch_agent':
        return ['prompt'];
      default:
        return [];
    }
  }
}