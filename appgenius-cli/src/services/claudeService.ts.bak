import axios from 'axios';
import { AIMessage, ClaudeResponse, StreamCallback, Tool, ToolUseResult } from '../types';
import { logger } from '../utils/logger';
import { configManager } from '../utils/configManager';
import { Readable } from 'stream';

// Claude API のベースURL
const CLAUDE_API_BASE_URL = 'https://api.anthropic.com/v1/messages';

// Claude モデル
export enum ClaudeModel {
  CLAUDE_3_OPUS = 'claude-3-opus-20240229',
  CLAUDE_3_SONNET = 'claude-3-sonnet-20240229',
  CLAUDE_3_HAIKU = 'claude-3-haiku-20240307',
  CLAUDE_3_SONNET_20250219 = 'claude-3-7-sonnet-20250219' // Claude 3.7
}

/**
 * Claude AI サービスのオプション
 */
export interface ClaudeServiceOptions {
  model?: ClaudeModel;
  maxTokens?: number;
  temperature?: number;
  systemPrompt?: string;
  streaming?: boolean;
}

/**
 * Claude AI サービスクラス
 * Claude APIを使用して自然言語処理を行う
 */
export class ClaudeService {
  private apiKey: string;
  private model: ClaudeModel;
  private maxTokens: number;
  private temperature: number;
  private systemPrompt: string;
  private tools: Map<string, Tool>;
  private conversation: AIMessage[] = [];
  private streaming: boolean = false; // ストリーミングモード
  
  // 並列ツール実行をサポートするための並列処理フラグ
  private parallelToolExecution: boolean = true;

  /**
   * コンストラクタ
   */
  constructor(options?: ClaudeServiceOptions) {
    const config = configManager.getConfig();
    this.apiKey = config.apiKey;
    this.model = options?.model || ClaudeModel.CLAUDE_3_SONNET_20250219; // デフォルトでClaude 3.7を使用
    this.maxTokens = options?.maxTokens || 100000; // ClaudeCodeと同じく大きなコンテキスト対応
    this.temperature = options?.temperature || 0.7;
    this.systemPrompt = options?.systemPrompt || this.getDefaultSystemPrompt();
    this.streaming = options?.streaming || false;
    this.tools = new Map();
    
    // ユーザー設定からストリーミングを読み込み
    if (config.userPreferences?.streamingEnabled !== undefined) {
      this.streaming = config.userPreferences.streamingEnabled;
    }
    
    // 並列ツール実行の設定
    this.parallelToolExecution = true;
    
    // システムプロンプトを会話履歴の最初に追加
    this.conversation = [
      { role: 'system', content: this.systemPrompt }
    ];
    
    logger.debug('Claude AIサービスを初期化しました', {
      model: this.model,
      maxTokens: this.maxTokens,
      temperature: this.temperature,
      streaming: this.streaming
    });
  }

  /**
   * デフォルトのシステムプロンプトを取得
   */
  private getDefaultSystemPrompt(): string {
    return `You are AppGenius, an AI assistant specialized in software development.
You help users with coding tasks, software architecture, debugging, and implementing features.
When a user asks for help with a task:

1. Break down the problem
2. Provide clear explanations
3. Generate well-structured, idiomatic code
4. Offer guidance on testing and best practices

You have access to tools for file operations, which allow you to search, read, and edit files.
When using these tools, be precise and careful, especially with file paths.

You are capable of "extended thinking" - when faced with complex problems, you'll break them down into steps
and work through them systematically, showing your reasoning. This helps with tasks like:
- Understanding complex codebases
- Designing software architecture
- Debugging difficult issues
- Optimizing performance problems

You specialize in TypeScript, JavaScript, Node.js, and web development, but can assist with most programming languages.
Always prioritize writing clean, maintainable, and efficient code.

IMPORTANT: Be proactive and thorough in your assistance. If you notice potential issues or improvements beyond what
the user explicitly asked for, politely mention them.`;
  }

  /**
   * APIキーを設定
   */
  public setApiKey(apiKey: string): void {
    this.apiKey = apiKey;
    configManager.setApiKey(apiKey);
  }

  /**
   * ツールを登録
   */
  public registerTool(tool: Tool): void {
    this.tools.set(tool.name, tool);
    logger.debug(`ツールを登録しました: ${tool.name}`);
  }

  /**
   * 複数のツールを登録
   */
  public registerTools(tools: Tool[]): void {
    tools.forEach(tool => this.registerTool(tool));
  }

  /**
   * 会話履歴をクリア（システムプロンプトは保持）
   */
  public clearConversation(): void {
    this.conversation = [this.conversation[0]]; // システムプロンプトのみ保持
    logger.debug('会話履歴をクリアしました');
  }

  /**
   * 会話履歴を取得
   */
  public getConversation(): AIMessage[] {
    return [...this.conversation];
  }

  /**
   * システムプロンプトを更新
   */
  public updateSystemPrompt(systemPrompt: string): void {
    this.systemPrompt = systemPrompt;
    
    // 会話履歴の最初のメッセージを更新
    if (this.conversation.length > 0 && this.conversation[0].role === 'system') {
      this.conversation[0].content = systemPrompt;
    } else {
      this.conversation.unshift({ role: 'system', content: systemPrompt });
    }
    
    logger.debug('システムプロンプトを更新しました');
  }
  
  /**
   * ストリーミング設定を変更
   */
  public setStreaming(enabled: boolean): void {
    this.streaming = enabled;
    logger.debug(`ストリーミングモードを${enabled ? '有効' : '無効'}にしました`);
  }
  
  /**
   * 並列ツール実行の設定を変更
   */
  public setParallelToolExecution(enabled: boolean): void {
    this.parallelToolExecution = enabled;
    logger.debug(`並列ツール実行を${enabled ? '有効' : '無効'}にしました`);
  }

  /**
   * Claude APIにメッセージを送信
   * @param message ユーザーメッセージ
   * @param streamCallback ストリーミング用コールバック
   */
  public async sendMessage(message: string, streamCallback?: StreamCallback): Promise<string> {
    try {
      if (!this.apiKey) {
        const errorMessage = 'Claude APIキーが設定されていません';
        logger.error(errorMessage);
        throw new Error(errorMessage);
      }
      
      // ユーザーメッセージを会話履歴に追加
      this.conversation.push({ role: 'user', content: message });
      
      logger.debug('Claude APIにリクエスト送信', {
        model: this.model,
        messageCount: this.conversation.length
      });
      
      // システムメッセージを取得
      const systemMessage = this.conversation[0].content;
      
      // メッセージ配列からシステムメッセージを除外
      const messagesWithoutSystem = this.conversation.filter(msg => msg.role !== 'system');
      
      // リクエストボディを構築 - ツール定義を含める
      const requestBody = {
        model: this.model,
        messages: messagesWithoutSystem,
        max_tokens: this.maxTokens,
        temperature: this.temperature,
        system: systemMessage,
        tools: Array.from(this.tools.values()).map(tool => ({
          name: tool.name,
          description: tool.description,
          input_schema: {
            type: "object",
            properties: this.getToolParameters(tool.name),
            required: this.getRequiredParameters(tool.name)
          }
        })),
        stream: this.streaming || !!streamCallback // ストリーミングコールバックがある場合はストリーミングを有効化
      };
      
      // 共通のヘッダー
      const headers = {
        'x-api-key': this.apiKey,
        'anthropic-version': '2023-06-01',
        'content-type': 'application/json',
        'Accept': 'application/json',
        'anthropic-beta': 'tools-2024-06-10' // ツール機能のベータ版を有効化
      };
      
      // ストリーミングモードの場合
      if (requestBody.stream && streamCallback) {
        let fullResponse = '';
        
        try {
          // ストリーミングAPIリクエスト
          const response = await axios.post(CLAUDE_API_BASE_URL, requestBody, {
            headers,
            responseType: 'stream'
          });
          
          // レスポンスをストリームとして処理
          const stream = response.data as Readable;
          
          // チャンクを処理
          await new Promise<void>((resolve, reject) => {
            stream.on('data', (chunk) => {
              try {
                const lines = chunk.toString().split('\n').filter(Boolean);
                
                for (const line of lines) {
                  if (line.startsWith('data: ')) {
                    const data = line.slice(6);
                    
                    // ストリームの終了を示す[DONE]を検出
                    if (data === '[DONE]') {
                      resolve();
                      return;
                    }
                    
                    try {
                      const parsed = JSON.parse(data);
                      
                      if (parsed.type === 'content_block_delta' && parsed.delta && parsed.delta.text) {
                        // テキストデルタを取得
                        const textChunk = parsed.delta.text;
                        fullResponse += textChunk;
                        
                        // コールバックでクライアントに送信
                        streamCallback(textChunk);
                      }
                    } catch (e) {
                      logger.warn('ストリーミングデータのパースに失敗しました', e);
                    }
                  }
                }
              } catch (err) {
                logger.error('ストリームチャンクの処理中にエラーが発生しました', err);
              }
            });
            
            stream.on('end', () => {
              resolve();
            });
            
            stream.on('error', (err) => {
              logger.error('ストリーム処理中にエラーが発生しました', err);
              reject(err);
            });
          });
          
          // アシスタントの応答を会話履歴に追加
          this.conversation.push({ role: 'assistant', content: fullResponse });
          
          return fullResponse;
        } catch (error) {
          logger.error('ストリーミング中にエラーが発生しました', error);
          throw error;
        }
      } else {
        // 通常のAPIリクエスト
        const response = await axios.post<ClaudeResponse>(CLAUDE_API_BASE_URL, requestBody, {
          headers
        });
        
        // レスポンスを処理
        const claudeResponse = response.data;

      // テキスト部分の抽出
      const textContent = claudeResponse.content
        .filter(item => item.type === 'text')
        .map(item => item.text || '')
        .join('');
      
      // ツール使用部分も文字列に含める
      const toolUseContent = claudeResponse.content
        .filter(item => item.tool_use || item.tool_result)
        .map(item => {
          if (item.tool_use) {
            return `[ツール使用: ${item.tool_use.name}]`;
          } else if (item.tool_result) {
            return `[ツール結果: ${item.tool_result.content.substring(0, 30)}...]`;
          }
          return '';
        })
        .join('\n');
      
      // 最終的なアシスタントメッセージを構築
      const assistantMessage = [textContent, toolUseContent].filter(Boolean).join('\n');
      
      // アシスタントの応答を会話履歴に追加
      this.conversation.push({ role: 'assistant', content: assistantMessage });
      
      logger.debug('Claude APIからの応答を受信', {
        inputTokens: claudeResponse.usage.inputTokens,
        outputTokens: claudeResponse.usage.outputTokens
      });
      
      return assistantMessage;
    } catch (error) {
      if (axios.isAxiosError(error)) {
        logger.error('Claude API呼び出しエラー', error);
        throw new Error(`Claude API呼び出しエラー: ${error.message}`);
      } else {
        logger.error('Claude APIとの通信中に予期しないエラーが発生しました', error as Error);
        throw error;
      }
    }
  }

  /**
   * ツール使用リクエストを検出・実行（ネイティブツールサポート対応）
   */
  public async detectAndExecuteTools(message: string): Promise<{ 
    responseText: string; 
    toolResults: ToolUseResult[];
  }> {
    try {
      // 会話履歴にユーザーメッセージを追加
      this.conversation.push({ role: 'user', content: message });
      
      // ツール定義をAnthropicネイティブ形式で構築
      const toolDefinitions = Array.from(this.tools.values()).map(tool => ({
        name: tool.name,
        description: tool.description,
        input_schema: {
          type: "object",
          properties: this.getToolParameters(tool.name),
          required: this.getRequiredParameters(tool.name)
        }
      }));
      
      // 特別なシステムプロンプトを構築
      const toolPrompt = `You have access to the following tools:
${JSON.stringify(toolDefinitions, null, 2)}

To use a tool, respond with:
<function_calls>
<invoke name="ToolName">
<parameter name="paramName">paramValue</parameter>
</invoke>
</function_calls>`;
      